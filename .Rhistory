library(devtools)
library(roxygen2)
library(cfdecomp)
?glm
library(cfdecomp)
library(cfdecomp)
library(cfdecomp)
devtools::document()
library(cfdecomp)
library(cfdecomp)
library(cfdecomp)
library(cfdecomp)
library(cfdecomp)
30/12
2.5*3
library(cfdecomp)
library(cfdecomp)
library(cfdecomp)
?cfd.mean
1+1
cfd.example.data
library(cfdecomp)
cfd.example.data
head(cfd.example.data)
table(cfd.example.data)
table(cfd.example.data$age)
library(cfdecomp)
?cfd.example.data
library(cfdecomp)
?cfd.example.data
?use_data
library(usethis)
?use_data
setwd('U:/Grant applications & Research proposals/MPIRG/Presentation Interview/LE')
LEdat <- read.csv('LEdata.csv')
View(LEdat)
?reshape
names(LEdat)
reshape(LEdat,idvar="Country.Name")
reshape(LEdat,idvar="Country.Name",direction='long')
LEdat$Country.Name
LEdat[LEdat$Country.Name=='United States']
LEdat[LEdat$Country.Name=='United States',]
LEdat[LEdat$Country.Name=='United States',-c(1:5)]
LEdat[LEdat$Country.Name=='United States',-c(1:4)]
LEdat[LEdat$Country.Name=='United Kingdom',-c(1:4)]
plot(1960:2018,LEdat[LEdat$Country.Name=='United Kingdom',-c(1:4)],type='line')
length(LEdat[LEdat$Country.Name=='United Kingdom',-c(1:4)])
LEdat[LEdat$Country.Name=='United Kingdom',c(5:64)]
LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)]
plot(1960:2018,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='line')
plot(1960:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='line')
plot(1960:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='l',lwd=2)
plot(1960:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='l',lwd=2,
ylim='Life expectancy in years',xlab='Calendar year')
plot(1960:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='l',lwd=2,
ylim='Life expectancy in years',xlab='Calendar year')
plot(1960:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='l',lwd=2,
ylab='Life expectancy in years',xlab='Calendar year')
plot(1960:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='l',lwd=2,
ylab='Life expectancy in years',xlab='Calendar year',ylim=c(68,86))
plot(1960:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='l',lwd=2,
ylab='Life expectancy in years',xlab='Calendar year',ylim=c(68,85))
plot(1960:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(5:62)],type='l',lwd=2,
ylab='Life expectancy in years',xlab='Calendar year',ylim=c(69,85))
plot(1970:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(15:62)],type='l',lwd=2,
ylab='Life expectancy in years',xlab='Calendar year',ylim=c(69,85))
lines(1970:2017,LEdat[LEdat$Country.Name=='United States',c(15:62)],lwd=2)
lines(1970:2017,LEdat[LEdat$Country.Name=='United States',c(15:62)],lwd=2,col='red')
legend(1970,85,col=c('black','red'),lwd=2,c('United Kingdom','USA'))
legend(1970,85,col=c('black','red'),lwd=2,c('United Kingdom'))
lines(1970:2017,LEdat[LEdat$Country.Name=='United States',c(15:62)],lwd=2,col='red')
legend(1970,85,col=c('black','red'),lwd=2,c('United Kingdom','USA'))
plot(1970:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(15:62)],type='l',lwd=2,
ylab='Life expectancy in years',xlab='Calendar year',ylim=c(69,85))
legend(1970,85,col=c('black','red'),lwd=2,c('United Kingdom'))
lines(1970:2017,LEdat[LEdat$Country.Name=='United States',c(15:62)],lwd=2,col='red')
legend(1970,85,col=c('black','red'),lwd=2,c('United Kingdom','USA'))
lines(1970:2017,LEdat[LEdat$Country.Name=='Germany',c(15:62)],lwd=2,col='Blue')
plot(1970:2017,LEdat[LEdat$Country.Name=='United Kingdom',c(15:62)],type='l',lwd=2,
ylab='Life expectancy in years',xlab='Calendar year',ylim=c(69,85))
legend(1970,85,col=c('black','red'),lwd=2,c('United Kingdom'))
lines(1970:2017,LEdat[LEdat$Country.Name=='United States',c(15:62)],lwd=2,col='red')
legend(1970,85,col=c('black','red'),lwd=2,c('United Kingdom','USA'))
library(cfdecomp)
library(roxygen2)
library(devtools)
library(cfdecomp)
library(devtools)
library(roxygen2)
library(cfdecomp)
library(cfdecomp)
library(cfdecomp)
library(cfdecomp)
?mass
library(MASS)
?mass
?MASS
library(cfdecomp)
library(cfdecomp)
library(cfdecomp)
?cfd.mean
library(cfdecomp)
cfd.mean <- function(formula.y,formula.m,mediator,group,
data,
family.y = 'binomial',
family.m = 'binomial',
bs.size = 1000,
mc.size=50,
alpha=0.05,
sample.resid=FALSE,
print.iteration=FALSE) {
## envir check
call <- match.call()
if (missing(data))
data <- environment(formula.y)
mf <- match.call(expand.dots = FALSE)
## get initial fit of outcome y
ini_fit.y <- glm(formula = formula.y,
data=data, family=family.y)
ini_fit.y$model_matrix <- model.matrix(as.formula(formula.y), data = data)
fam.y <- family(ini_fit.y)
## get initial fit of mediator m
ini_fit.m <- glm(formula = formula.m,
data=data, family=family.m)
ini_fit.m$model_matrix <- model.matrix(as.formula(formula.m), data = data)
fam.m <- family(ini_fit.m)
## loop over bootstrap samples
out_nc_m <- matrix(NA,nrow=bs.size,ncol=nlevels(data[,group]),dimnames = list(1:bs.size,levels(data[,group])))
out_cf_m <- matrix(NA,nrow=bs.size,ncol=nlevels(data[,group]),dimnames = list(1:bs.size,levels(data[,group])))
out_nc_y <- matrix(NA,nrow=bs.size,ncol=nlevels(data[,group]),dimnames = list(1:bs.size,levels(data[,group])))
out_cf_y <- matrix(NA,nrow=bs.size,ncol=nlevels(data[,group]),dimnames = list(1:bs.size,levels(data[,group])))
## temp matrix to save mc results
temp_nc_m <- matrix(NA, nrow=mc.size, ncol=nlevels(data[,group]))
temp_cf_m <- matrix(NA, nrow=mc.size, ncol=nlevels(data[,group]))
temp_nc_y <- matrix(NA, nrow=mc.size, ncol=nlevels(data[,group]))
temp_cf_y <- matrix(NA, nrow=mc.size, ncol=nlevels(data[,group]))
for(i in 1:bs.size) {
if(print.iteration==TRUE){print(i)}
## resampling
resample_ind <- sample(nrow(data), replace=TRUE)
data_bs <- data[resample_ind,]
## refit models for y and m
bs_fit.y <- update(ini_fit.y, data = data_bs)
coef_bs.y <- coef(bs_fit.y)
bs_fit.m <- update(ini_fit.m, data = data_bs)
coef_bs.m <- coef(bs_fit.m)
if(family.m[1]=='gaussian' & sample.resid==FALSE) {sd.ref.m <- sd(bs_fit.m$residuals[data_bs[,group]==levels(data_bs[,group])[1]])}
if(family.m[1]=='gaussian' & sample.resid==TRUE) {resid.ref.m <- bs_fit.m$residuals[data_bs[,group]==levels(data_bs[,group])[1]]}
# save group identifier in an additional column since
# we overwrite it to create counterfactuals
data_bs$truegroup <- data_bs[,group]
## start Monte Carlo loop
## ! The parametric version does not equalize mediator values over strata
for(ii in 1:mc.size){
# save and overwrite data_mc since we create counterfactuals later
data_mc <- data_bs
## natural course simulation ##
# simulate mediator
pred_mean_m <- predict(bs_fit.m,data_mc,type='response')
n <- length(pred_mean_m)
if(family.m[1]=='poisson') {data_mc[,mediator] <- rpois(n,pred_mean_m)} else if
(family.m[1]=='binomial') {data_mc[,mediator] <- rbinom(n,1,pred_mean_m)} else if
(family.m[1]=='gaussian' & sample.resid==FALSE) {data_mc[,mediator] <- rnorm(n,pred_mean_m,sd=sd.ref.m)} else if
(family.m[1]=='gaussian' & sample.resid==TRUE) {data_mc[,mediator] <- pred_mean_m + sample(resid.ref.m,n,replace=TRUE)}
temp_nc_m[ii,] <-  tapply(data_mc[,mediator], list(data_mc[,group]),mean,na.rm=T)
# simulate outome
# ! Note that this function predicts means only because it compares means
# ! Hence the entire distribution of values (of the outcome) is not re-created
# ! If that is desired, see the function for the quantiles instead.
pred_mc_nc <- predict(bs_fit.y,data_mc,type='response')
temp_nc_y[ii,] <-  tapply(pred_mc_nc, list(data_mc[,group]),mean,na.rm=T)
## counterfactual simulation ##
# equalize distribution of mediator
# this is done by assigning everyone the reference group and then (re)predicting
data_mc[,group][which(data_mc[,group] %in% levels(data_mc[,group])[-1])] <- levels(data_mc[,group])[1]
pred_mean_m <- predict(bs_fit.m,data_mc,type='response')
if(family.m[1]=='poisson') {data_mc[,mediator] <- rpois(n,pred_mean_m)} else if
(family.m[1]=='binomial') {data_mc[,mediator] <- rbinom(n,1,pred_mean_m)} else if
(family.m[1]=='gaussian' & sample.resid==FALSE) {data_mc[,mediator] <- rnorm(n,pred_mean_m,sd=sd.ref.m)} else if
(family.m[1]=='gaussian' & sample.resid==TRUE) {data_mc[,mediator] <- pred_mean_m + sample(resid.ref.m,n,replace=TRUE)}
temp_cf_m[ii,] <-  tapply(data_mc[,mediator], list(data_mc$truegroup),mean,na.rm=T)
# set group identifier back to true levels
data_mc[,group] <- data_mc$truegroup
# simulate outcome
pred_mc_cf <- predict(bs_fit.y,data_mc,type='response')
temp_cf_y[ii,] <-  tapply(pred_mc_cf, list(data_mc$truegroup),mean,na.rm=T)
}
# for thef first bootstrap iteration, also save mc information
# to be used for convergence information
if(i==1) {
mc_conv_info_m <- apply(temp_nc_m,2,conv.mean)
mc_conv_info_y <- apply(temp_nc_y,2,conv.mean)
}
## save results for this bootstrap iteration
out_nc_m[i,] <- apply(temp_nc_m,2,mean,na.rm=T)
out_cf_m[i,] <- apply(temp_cf_m,2,mean,na.rm=T)
out_nc_y[i,] <- apply(temp_nc_y,2,mean,na.rm=T)
out_cf_y[i,] <- apply(temp_cf_y,2,mean,na.rm=T)
}
return(list(out_nc_m=out_nc_m,
out_cf_m=out_cf_m,
out_nc_quantile_m=apply(out_nc_m,2,quantile,c(alpha/2,0.5,1-alpha/2)),
out_cf_quantile_m=apply(out_cf_m,2,quantile,c(alpha/2,0.5,1-alpha/2)),
out_nc_y=out_nc_y,
out_cf_y=out_cf_y,
out_nc_quantile_y=apply(out_nc_y,2,quantile,c(alpha/2,0.5,1-alpha/2)),
out_cf_quantile_y=apply(out_cf_y,2,quantile,c(alpha/2,0.5,1-alpha/2)),
mediation=apply(1-(out_cf_y - out_nc_y[,1]) / (out_nc_y - out_nc_y[,1]),2,mean)[-1],
mediation_quantile=apply(1-(out_cf_y - out_nc_y[,1]) / (out_nc_y - out_nc_y[,1]),2,quantile,probs=c(alpha/2,1-alpha/2),na.rm=T)[,-1],
mc_conv_info_m=mc_conv_info_m,
mc_conv_info_y=mc_conv_info_y
)
)
}
mean.results.1 <- cfd.mean(formula.y='out.gauss ~ SES + med.gauss + med.binom + age',
formula.m='med.gauss ~ SES + age',
mediator='med.gauss',
group='SES',
data=cfd.example.data,
family.y='gaussian',
family.m='gaussian',
bs.size=250,
mc.size=50,
alpha=0.05)
library(cfdecomp)
library(devtools)
library(roxygen2)
